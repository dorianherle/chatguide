ChatGuide PYTHON Codebase Export - 2025-12-15 23:55:17
================================================================================

SUMMARY
------------------------------
Total Python files: 26
Total size: 98,506 bytes (96.2 KB)
Total lines: 2,680

CATEGORY BREAKDOWN
------------------------------
OTHER: 1 files, 35 lines, 0.8 KB
CORE_PACKAGE: 6 files, 957 lines, 35.0 KB
BUILDERS: 2 files, 275 lines, 9.2 KB
CORE_ENGINE: 6 files, 378 lines, 12.4 KB
IO_LAYER: 3 files, 251 lines, 8.7 KB
TOOLS: 2 files, 3 lines, 0.1 KB
UTILITIES: 5 files, 699 lines, 27.4 KB
SCRIPTS: 1 files, 82 lines, 2.6 KB

FILE DETAILS
------------------------------

[OTHER]
-------
  python/chatguide\__init__.py
    Size: 846 bytes | Lines: 35 | Modified: 2025-12-13 17:00:39

[CORE_PACKAGE]
--------------
  python/chatguide\adjustments.py
    Size: 6,941 bytes | Lines: 214 | Modified: 2025-12-15 20:20:13
  python/chatguide\chatguide.py
    Size: 15,779 bytes | Lines: 379 | Modified: 2025-12-15 23:36:56
  python/chatguide\plan.py
    Size: 2,843 bytes | Lines: 87 | Modified: 2025-12-13 17:00:39
  python/chatguide\schemas.py
    Size: 3,702 bytes | Lines: 95 | Modified: 2025-12-15 23:15:15
  python/chatguide\state.py
    Size: 4,616 bytes | Lines: 122 | Modified: 2025-12-15 20:20:13
  python/chatguide\tool_executor.py
    Size: 1,952 bytes | Lines: 60 | Modified: 2025-12-14 13:04:37

[BUILDERS]
----------
  python/chatguide\builders\__init__.py
    Size: 15 bytes | Lines: 1 | Modified: 2025-12-13 16:52:15
  python/chatguide\builders\prompt.py
    Size: 9,421 bytes | Lines: 274 | Modified: 2025-12-15 23:36:56

[CORE_ENGINE]
-------------
  python/chatguide\core\__init__.py
    Size: 249 bytes | Lines: 9 | Modified: 2025-12-14 09:55:45
  python/chatguide\core\audit.py
    Size: 2,495 bytes | Lines: 84 | Modified: 2025-12-13 17:00:39
  python/chatguide\core\block.py
    Size: 1,246 bytes | Lines: 37 | Modified: 2025-12-13 17:00:39
  python/chatguide\core\context.py
    Size: 2,445 bytes | Lines: 69 | Modified: 2025-12-15 20:20:13
  python/chatguide\core\execution.py
    Size: 3,023 bytes | Lines: 88 | Modified: 2025-12-15 20:20:13
  python/chatguide\core\task.py
    Size: 3,207 bytes | Lines: 91 | Modified: 2025-12-15 20:20:13

[IO_LAYER]
----------
  python/chatguide\io\__init__.py
    Size: 9 bytes | Lines: 1 | Modified: 2025-12-13 16:52:15
  python/chatguide\io\llm.py
    Size: 3,586 bytes | Lines: 104 | Modified: 2025-12-14 10:31:50
  python/chatguide\io\storage.py
    Size: 5,288 bytes | Lines: 146 | Modified: 2025-12-13 16:52:15

[TOOLS]
-------
  python/chatguide\tools\__init__.py
    Size: 73 bytes | Lines: 1 | Modified: 2025-12-13 16:52:15
  python/chatguide\tools\html\__init__.py
    Size: 38 bytes | Lines: 2 | Modified: 2025-12-13 16:52:15

[UTILITIES]
-----------
  python/chatguide\utils\__init__.py
    Size: 12 bytes | Lines: 1 | Modified: 2025-12-13 16:52:15
  python/chatguide\utils\config_loader.py
    Size: 13,711 bytes | Lines: 325 | Modified: 2025-12-15 23:15:15
  python/chatguide\utils\debug_formatter.py
    Size: 6,983 bytes | Lines: 181 | Modified: 2025-12-13 16:52:15
  python/chatguide\utils\logger.py
    Size: 4,739 bytes | Lines: 127 | Modified: 2025-12-13 16:52:15
  python/chatguide\utils\response_parser.py
    Size: 2,630 bytes | Lines: 65 | Modified: 2025-12-15 20:20:13

[SCRIPTS]
---------
  python/scripts\validate_config.py
    Size: 2,657 bytes | Lines: 82 | Modified: 2025-12-15 22:41:27


================================================================================
SOURCE CODE
================================================================================


================================================================================
CATEGORY: OTHER
================================================================================

------------------------------------------------------------
FILE: python/chatguide\__init__.py
CATEGORY: OTHER
STATS: 35 lines, 846 bytes
MODIFIED: 2025-12-13 17:00:39
FULL PATH: C:\Users\photo\Desktop\chatguide\python\chatguide\__init__.py
------------------------------------------------------------

﻿"""ChatGuide - State-driven conversational agent framework."""

from .chatguide import ChatGuide
from .state import State
from .plan import Plan
from .adjustments import Adjustments, Adjustment
from .tool_executor import register_tool, get_tool_registry
from .schemas import ChatGuideReply, TaskDefinition, ToolCall, TaskResult

# Register built-in HTML tools
register_tool(
    "html.button_choice",
    "ui",
    "Display clickable button options for user to choose from"
)

register_tool(
    "html.card_swipe",
    "ui",
    "Display animated credit card swipe for payment processing"
)

__all__ = [
    "ChatGuide",
    "State",
    "Plan",
    "Adjustments",
    "Adjustment",
    "register_tool",
    "get_tool_registry",
    "ChatGuideReply",
    "TaskDefinition",
    "ToolCall",
    "TaskResult"
]


--------------------------------------------------------------------------------


================================================================================
CATEGORY: CORE_PACKAGE
================================================================================

------------------------------------------------------------
FILE: python/chatguide\adjustments.py
CATEGORY: CORE_PACKAGE
STATS: 214 lines, 6,941 bytes
MODIFIED: 2025-12-15 20:20:13
FULL PATH: C:\Users\photo\Desktop\chatguide\python\chatguide\adjustments.py
------------------------------------------------------------

"""Adjustments - reactive rules that monitor state and modify plan/tone/state."""

import logging
import re
from typing import List, Dict, Any, Callable, Union, TYPE_CHECKING
from dataclasses import dataclass

if TYPE_CHECKING:
    from .state import State
    from .plan import Plan
else:
    from .core.block import Block
    from .core.task import Task


logger = logging.getLogger(__name__)


class Adjustment:
    """Single adjustment rule with safe condition evaluation."""
    
    def __init__(
        self, 
        name: str, 
        condition: Union[Dict[str, Any], bool], 
        actions: List[Dict[str, Any]]
    ):
        self.name = name
        self.condition = condition
        self.actions = actions
        self.fired = False
    
    def reset(self):
        """Reset fired flag."""
        self.fired = False
    
    def evaluate_condition(self, state: "State", plan: "Plan", tone: List[str]) -> bool:
        """Evaluate condition using declarative AST."""
        if isinstance(self.condition, bool):
            return self.condition
            
        if isinstance(self.condition, dict):
            return self._eval_condition(self.condition, state, plan, tone)
            
        return False
    
    def _eval_condition(self, cond: Dict[str, Any], state: "State", plan: "Plan", tone: List[str]) -> bool:
        """Recursive AST evaluator."""
        # Logic operators
        if "all" in cond:
            return all(self._eval_condition(c, state, plan, tone) for c in cond["all"])
        if "any" in cond:
            return any(self._eval_condition(c, state, plan, tone) for c in cond["any"])
        if "not" in cond:
            return not self._eval_condition(cond["not"], state, plan, tone)
            
        # Leaf operators
        if "has" in cond:
            return state.get(cond["has"]) is not None
        
        if "eq" in cond:
            actual = state.get(cond["eq"]["key"])
            expected = cond["eq"]["value"]
            return actual == expected
            
        if "gt" in cond:
            val = float(state.get(cond["gt"]["key"], 0))
            return val > cond["gt"]["value"]
            
        return False


@dataclass
class Action:
    """Base class for adjustment actions."""
    pass

@dataclass
class PlanJump(Action):
    index: int

@dataclass
class PlanInsertBlock(Action):
    index: int
    tasks: List[str]

@dataclass
class PlanRemoveBlock(Action):
    index: int

@dataclass
class PlanReplaceBlock(Action):
    index: int
    tasks: List[str]

@dataclass
class ToneSet(Action):
    tones: List[str]

@dataclass
class ToneAdd(Action):
    tone: str

@dataclass
class StateSet(Action):
    key: str
    value: Any

class Adjustments:
    """Adjustment evaluation engine.
    
    Reactive rules watching state and mutating plan/tone/state.
    """
    
    def __init__(self, adjustments: List[Adjustment] = None):
        self._adjustments = adjustments or []
    
    def add(self, adjustment: Adjustment):
        """Add adjustment rule."""
        self._adjustments.append(adjustment)
    
    def evaluate(self, state: "State", plan: "Plan", tone: List[str]) -> List[str]:
        """Evaluate all adjustments and execute matching ones.
        
        Returns list of adjustment names that fired.
        """
        fired_names = []
        
        for adj in self._adjustments:
            if adj.fired:
                continue
            
            try:
                if adj.evaluate_condition(state, plan, tone):
                    self._execute_actions(adj.actions, state, plan, tone)
                    adj.fired = True
                    fired_names.append(adj.name)
            except Exception as e:
                # Log the error instead of silently swallowing
                logger.warning(f"Adjustment '{adj.name}' condition evaluation failed: {e}")
        
        return fired_names
    
    def _execute_actions(self, actions: List[Union[Dict[str, Any], Action]], state: "State", 
                        plan: "Plan", tone: List[str]):
        """Execute adjustment actions."""
        for action in actions:
            # Handle legacy dict actions (for backward compat if needed)
            if isinstance(action, dict):
                 # Convert to object (simplified) or execute old logic
                 # For cleanliness, we'll try to execute logic directly here if it's a dict
                 action_type = action.get("type")
                 index = action.get("index", 0)
                 task_ids = action.get("tasks", [])
                 
                 if action_type == "plan.insert_block":
                     tasks = [Task(id=tid, description="") for tid in task_ids]
                     plan.insert_block(index, Block(tasks))
                 elif action_type == "plan.remove_block":
                     plan.remove_block(index)
                 elif action_type == "plan.replace_block":
                     tasks = [Task(id=tid, description="") for tid in task_ids]
                     plan.replace_block(index, Block(tasks))
                 elif action_type == "plan.jump_to":
                     plan.jump_to(index)
                 elif action_type == "tone.set":
                     tone.clear()
                     tone.extend(action.get("tones", []))
                 return # Skip rest

            # Handle Typed Actions
            if isinstance(action, PlanInsertBlock):
                tasks = [Task(id=tid, description="") for tid in action.tasks]
                plan.insert_block(action.index, Block(tasks))
            
            elif isinstance(action, PlanRemoveBlock):
                plan.remove_block(action.index)
            
            elif isinstance(action, PlanReplaceBlock):
                tasks = [Task(id=tid, description="") for tid in action.tasks]
                plan.replace_block(action.index, Block(tasks))
            
            elif isinstance(action, PlanJump):
                plan.jump_to(action.index)
            
            elif isinstance(action, ToneSet):
                tone.clear()
                tone.extend(action.tones)
            
            elif isinstance(action, ToneAdd):
                if action.tone and action.tone not in tone:
                    tone.append(action.tone)
            
            elif isinstance(action, StateSet):
                if action.key:
                    state.set(action.key, action.value)
    
    def reset_all(self):
        """Reset all fired flags."""
        for adj in self._adjustments:
            adj.reset()
    
    def to_dict(self) -> dict:
        """Export adjustments as dict."""
        return {
            "adjustments": [
                {
                    "name": adj.name,
                    "condition": adj.condition,
                    "fired": adj.fired
                }
                for adj in self._adjustments
            ]
        }


--------------------------------------------------------------------------------

------------------------------------------------------------
FILE: python/chatguide\chatguide.py
CATEGORY: CORE_PACKAGE
STATS: 379 lines, 15,779 bytes
MODIFIED: 2025-12-15 23:36:56
FULL PATH: C:\Users\photo\Desktop\chatguide\python\chatguide\chatguide.py
------------------------------------------------------------

"""ChatGuide - lean conversational agent framework."""

from typing import Dict, Any, Optional, Union, List
from .schemas import ChatGuideReply, ExpectDefinition, TaskResult
from .core.task import Task
from .builders.prompt import PromptBuilder, PromptView
from .io.llm import run_llm
from .utils.config_loader import load_config_file, validate_config, normalize_expects
from .utils.response_parser import parse_llm_response


class ChatGuide:
    """State-driven conversational agent."""
    
    def __init__(self, api_key: str = None, config: Any = None, debug: bool = False):
        self.api_key = api_key
        self.debug = debug
        self.config_path = config if isinstance(config, str) else None  # Store path for reloading

        # === SINGLE SOURCE OF TRUTH ===
        # Everything dynamic lives in state
        self.state = {
            "data": {},           # Extracted key-value data
            "messages": [],       # Conversation history
            "block": 0,           # Current block index
            "completed": set(),   # Completed task IDs
            "recent_keys": [],    # Recent keys in order of extraction/correction
        }

        # === STATIC CONFIG (loaded once) ===
        self.config = {
            "tasks": {},          # task_id -> {description, expects, silent}
            "blocks": [],         # [[task_ids], [task_ids], ...]
            "tone": "",
            "guardrails": "",
            "language": "en",
        }

        if config:
            self._load_config(config)

    def reload_config(self) -> bool:
        """Reload configuration from the original path. Returns True if successful."""
        if not self.config_path:
            return False

        try:
            # Store current state to preserve conversation
            current_state = self.state.copy()

            # Reload config
            self._load_config(self.config_path)

            # Restore state (but reset block progression to avoid inconsistencies)
            self.state = current_state

            if self.debug:
                print(f"[DEBUG] Config reloaded from {self.config_path}")
            return True
        except Exception as e:
            if self.debug:
                print(f"[ERROR] Config reload failed: {e}")
            return False

    # =========== CONFIG ===========
    
    def _load_config(self, config: Union[str, Dict]):
        """Load configuration with validation."""
        data = config if isinstance(config, dict) else load_config_file(config)

        # Validate config
        errors = validate_config(data)
        if errors:
            error_msg = "Configuration validation failed:\n" + "\n".join(f"- {err}" for err in errors)
            raise ValueError(error_msg)

        # Blocks (plan)
        self.config["blocks"] = data.get("plan", [])

        # Tasks
        for task_id, task_def in data.get("tasks", {}).items():
            expects = task_def.get("expects", [])
            # Normalize expects using the new function
            normalized = normalize_expects(expects)

            self.config["tasks"][task_id] = {
                "description": task_def.get("description", ""),
                "expects": normalized,
                "silent": task_def.get("silent", False),
            }
        
        # Tone
        tone_ids = data.get("tone", [])
        tone_defs = data.get("tones", {})
        if tone_ids:
            self.config["tone"] = " ".join(
                tone_defs.get(t, {}).get("description", t) if isinstance(tone_defs.get(t), dict) else t
                for t in tone_ids
            )
        
        # Guardrails & language
        guardrails = data.get("guardrails", [])
        self.config["guardrails"] = "\n".join(guardrails) if isinstance(guardrails, list) else guardrails
        self.config["language"] = data.get("language", "en")
        
        # Initial state data
        if "state" in data:
            self.state["data"].update(data["state"])
    
    # =========== CHAT ===========
    
    def chat(self, model: str = "gemini/gemini-2.0-flash-exp", api_key: str = None, max_retries: int = 2) -> ChatGuideReply:
        """Execute one chat turn. Re-asks if task not complete due to null values."""
        retry_count = 0
        while retry_count < max_retries:
            task = self._current_task()
            is_silent = task and task.get("silent", False)

            if self.debug:
                block_idx = self.state["block"]
                current_block_tasks = self._current_block_tasks()
                pending_in_block = [tid for tid in current_block_tasks if tid not in self.state["completed"]]
                current_task_id = self._current_task_id()
                if current_task_id:
                    is_complete = self._task_is_complete(current_task_id)
                    print(f"[DEBUG] Block {block_idx}: {len(pending_in_block)} pending tasks {pending_in_block}, current task: {current_task_id}, complete: {is_complete}")
                else:
                    print(f"[DEBUG] Block {block_idx}: {len(pending_in_block)} pending tasks {pending_in_block}, no current task")

            # Build prompt and call LLM
            prompt = self._build_prompt()
            reply = self._call_llm(prompt, model, api_key or self.api_key)

            # Update state
            self._process_reply(reply)

            # Check if current task is complete
            current_task_id = self._current_task_id()
            if current_task_id and not self._task_is_complete(current_task_id):
                # Task not complete due to null values - re-ask by continuing the loop
                retry_count += 1
                if retry_count < max_retries:
                    if self.debug:
                        null_keys = [exp.key for exp in task.get("expects", []) if self.state["data"].get(exp.key) is None]
                        print(f"[DEBUG] Task '{current_task_id}' incomplete due to null values for keys: {null_keys}. Re-asking... ({retry_count}/{max_retries})")
                    continue
                else:
                    # Max retries reached - force completion with current data (may include nulls)
                    if self.debug:
                        print(f"[DEBUG] Max retries ({max_retries}) reached for task '{current_task_id}', force-completing with available data")
                    self.state["completed"].add(current_task_id)

                    # Advance if block complete
                    if self._block_complete():
                        if self.debug:
                            print(f"[DEBUG] Block {self.state['block']} complete, advancing to block {self.state['block'] + 1}")
                        self.state["block"] += 1

            # Silent tasks loop, visible tasks return
            if not is_silent:
                self.state["messages"].append({"role": "assistant", "content": reply.assistant_reply})
                return reply
    
    def add_user_message(self, message: str):
        """Add user message."""
        self.state["messages"].append({"role": "user", "content": message})
    
    # =========== STATE HELPERS ===========
    
    @property
    def data(self) -> Dict:
        """Shortcut to extracted data."""
        return self.state["data"]
    
    @property
    def messages(self) -> List:
        """Shortcut to conversation history."""
        return self.state["messages"]
    
    def _current_task(self) -> Optional[Dict]:
        """Get current task definition."""
        task_id = self._current_task_id()
        return self.config["tasks"].get(task_id) if task_id else None
    
    def _current_task_id(self) -> Optional[str]:
        """Get current task ID."""
        blocks = self.config["blocks"]
        idx = self.state["block"]
        if idx >= len(blocks):
            return None
        for task_id in blocks[idx]:
            if task_id not in self.state["completed"]:
                return task_id
        return None
    
    def is_finished(self) -> bool:
        """Check if all blocks complete."""
        return self.state["block"] >= len(self.config["blocks"])
    
    def get_progress(self) -> Dict:
        """Get progress info."""
        total = sum(len(b) for b in self.config["blocks"])
        completed = len(self.state["completed"])
        return {
            "completed": completed,
            "total": total,
            "percent": int(completed / total * 100) if total else 100,
            "current_task": self._current_task_id(),
        }
    
    # =========== INTERNAL ===========
    
    def _build_prompt(self) -> str:
        """Build LLM prompt."""
        # Current task
        current_task = self._make_task(self._current_task_id())
        
        # Pending tasks in current block
        pending = [self._make_task(tid) for tid in self._current_block_tasks() 
                   if tid not in self.state["completed"]]
        
        # Next block's first task (for smooth transitions)
        next_block_task = None
        next_idx = self.state["block"] + 1
        if next_idx < len(self.config["blocks"]) and self.config["blocks"][next_idx]:
            next_block_task = self._make_task(self.config["blocks"][next_idx][0])
        
        # Get recent extractions from state
        recent_extractions = [
            {"key": k, "value": self.state["data"][k]}
            for k in self.state["recent_keys"][-10:]  # Last 10 recent keys
        ]

        view = PromptView(
            current_task=current_task,
            pending_tasks=pending,
            completed_tasks=list(self.state["completed"]),
            state=self.state["data"],
            tone_text=self.config["tone"] or "Natural and helpful",
            guardrails=self.config["guardrails"],
            history=self.state["messages"],
            language=self.config["language"],
            next_block_task=next_block_task,
            recent_extractions=recent_extractions,
        )
        return PromptBuilder(view).build()
    
    def _make_task(self, task_id: str) -> Optional[Task]:
        """Create Task object from config."""
        if not task_id:
            return None
        tdef = self.config["tasks"].get(task_id, {})
        return Task(
            id=task_id,
            description=tdef.get("description", ""),
            expects=tdef.get("expects", []),
            silent=tdef.get("silent", False),
        )
    
    def _call_llm(self, prompt: str, model: str, api_key: str) -> ChatGuideReply:
        """Call LLM."""
        try:
            result = run_llm(
                prompt, model=model, api_key=api_key,
                extra_config={"response_schema": ChatGuideReply.model_json_schema()}
            )
            return parse_llm_response(result.content)
        except Exception as e:
            if self.debug:
                print(f"[ERROR] {e}")
            return ChatGuideReply(assistant_reply=f"Error: {e}", task_results=[], tools=[])
    
    def _process_reply(self, reply: ChatGuideReply):
        """Process reply: update state, complete tasks, advance."""
        current_task_id = self._current_task_id()
        if not current_task_id:
            return

        current_task_def = self.config["tasks"].get(current_task_id, {})
        expected_keys = [exp.key for exp in current_task_def.get("expects", [])]

        # 1. STRICT KEY WHITELIST: Only accept keys listed in current task's expects
        filtered_results = []
        for tr in reply.task_results:
            if tr.key in expected_keys:
                filtered_results.append(tr)
            elif self.debug:
                print(f"[WARNING] Rejected unexpected key '{tr.key}' from task results (not in expects)")

        # 2. MANDATORY EXTRACTION ENTRIES: Ensure one result per expected key
        # Create TaskResult objects for missing keys with value=None
        result_dict = {tr.key: tr for tr in filtered_results}
        complete_results = []

        for expected_key in expected_keys:
            if expected_key in result_dict:
                complete_results.append(result_dict[expected_key])
            else:
                # Missing key - create with null value
                complete_results.append(TaskResult(
                    task_id=current_task_id,
                    key=expected_key,
                    value=None
                ))
                if self.debug:
                    print(f"[DEBUG] Added missing result for key '{expected_key}' with null value")

        # 3. Update data and track recent keys
        for tr in complete_results:
            self.state["data"][tr.key] = tr.value
            if tr.key not in self.state["recent_keys"]:
                self.state["recent_keys"].append(tr.key)

        # 4. Check if current task is complete (all non-null)
        if self._task_is_complete(current_task_id):
            self.state["completed"].add(current_task_id)
            if self.debug:
                print(f"[DEBUG] Completed task '{current_task_id}' (all expected keys have non-null values)")

            # 5. Advance if block complete
            if self._block_complete():
                if self.debug:
                    print(f"[DEBUG] Block {self.state['block']} complete, advancing to block {self.state['block'] + 1}")
                self.state["block"] += 1

    def _task_is_complete(self, task_id: str) -> bool:
        """Check if task is complete: all expected keys have non-null values."""
        task_def = self.config["tasks"].get(task_id, {})
        expected_keys = [exp.key for exp in task_def.get("expects", [])]
        return all(self.state["data"].get(key) is not None for key in expected_keys)

    def _validate_runtime_state(self):
        """Validate runtime state for consistency."""
        errors = []

        # Check that all completed tasks actually exist
        for task_id in self.state["completed"]:
            if task_id not in self.config["tasks"]:
                errors.append(f"Completed task '{task_id}' not found in config")

        # Check that extracted data matches task expectations
        for task_id in self.state["completed"]:
            task_def = self.config["tasks"].get(task_id, {})
            expects = task_def.get("expects", [])

            # If task has expects, check that at least one key was extracted
            if expects:
                extracted_any = False
                for exp in expects:
                    exp_key = exp.key if hasattr(exp, 'key') else exp
                    if exp_key in self.state["data"]:
                        extracted_any = True
                        break

                if not extracted_any and self.debug:
                    print(f"[WARNING] Task '{task_id}' completed but no expected keys found in data")

        if errors and self.debug:
            print(f"[WARNING] Runtime validation errors: {errors}")
    
    def _current_block_tasks(self) -> List[str]:
        """Get task IDs in current block."""
        blocks = self.config["blocks"]
        idx = self.state["block"]
        return blocks[idx] if idx < len(blocks) else []
    
    def _block_complete(self) -> bool:
        """Check if current block is complete."""
        return all(tid in self.state["completed"] for tid in self._current_block_tasks())
    
    def _find_task_for_key(self, key: str) -> Optional[str]:
        """Find task that expects this key."""
        for task_id in self._current_block_tasks():
            task_def = self.config["tasks"].get(task_id, {})
            for exp in task_def.get("expects", []):
                exp_key = exp.key if hasattr(exp, "key") else exp
                if exp_key == key:
                    return task_id
        return None


--------------------------------------------------------------------------------

------------------------------------------------------------
FILE: python/chatguide\plan.py
CATEGORY: CORE_PACKAGE
STATS: 87 lines, 2,843 bytes
MODIFIED: 2025-12-13 17:00:39
FULL PATH: C:\Users\photo\Desktop\chatguide\python\chatguide\plan.py
------------------------------------------------------------

"""Plan - ordered sequence of task blocks with manipulation methods."""

from typing import List, Optional
from .core.block import Block
from .core.task import Task

class Plan:
    """Ordered list of task blocks defining execution flow.
    
    Manages a sequence of Block objects.
    """
    
    def __init__(self, blocks: List[Block] = None):
        self._blocks: List[Block] = blocks or []
        self._current_index = 0
    
    def get_current_block(self) -> Optional[Block]:
        """Get current task block."""
        if self._current_index < len(self._blocks):
            return self._blocks[self._current_index]
        return None
    
    def get_block(self, index: int) -> Optional[Block]:
        """Get task block at index."""
        if 0 <= index < len(self._blocks):
            return self._blocks[index]
        return None
    
    def advance(self):
        """Move to next block."""
        if self._current_index < len(self._blocks):
            self._current_index += 1
    
    def jump_to(self, index: int):
        """Jump to specific block."""
        if 0 <= index < len(self._blocks):
            self._current_index = index
    
    def insert_block(self, index: int, block: Block):
        """Insert task block at index."""
        self._blocks.insert(index, block)
    
    def remove_block(self, index: int):
        """Remove block at index."""
        if 0 <= index < len(self._blocks):
            self._blocks.pop(index)
    
    def replace_block(self, index: int, block: Block):
        """Replace block at index."""
        if 0 <= index < len(self._blocks):
            self._blocks[index] = block
            
    def get_all_tasks(self) -> List[Task]:
        """Get all tasks in the plan."""
        tasks = []
        for block in self._blocks:
            tasks.extend(block.tasks)
        return tasks
        
    def get_task(self, task_id: str) -> Optional[Task]:
        """Find a task by ID anywhere in the plan."""
        for block in self._blocks:
            task = block.get_task(task_id)
            if task:
                return task
        return None
    
    def is_finished(self) -> bool:
        """Check if plan is complete."""
        return self._current_index >= len(self._blocks)
    
    @property
    def current_index(self) -> int:
        """Get current block index."""
        return self._current_index
    
    def to_dict(self) -> dict:
        """Export plan as dict."""
        return {
            "blocks": [b.to_dict() for b in self._blocks],
            "current_index": self._current_index,
            "is_finished": self.is_finished()
        }
    
    def __repr__(self):
        return f"Plan(blocks={len(self._blocks)}, current={self._current_index})"



--------------------------------------------------------------------------------

------------------------------------------------------------
FILE: python/chatguide\schemas.py
CATEGORY: CORE_PACKAGE
STATS: 95 lines, 3,702 bytes
MODIFIED: 2025-12-15 23:15:15
FULL PATH: C:\Users\photo\Desktop\chatguide\python\chatguide\schemas.py
------------------------------------------------------------

"""Pydantic schemas for ChatGuide."""

from pydantic import BaseModel, Field
from typing import List, Dict, Any, Optional, Union


class ExpectDefinition(BaseModel):
    """Definition for an expected value with optional validation.
    
    Only use for:
    - Numbers with min/max range (e.g., age: 1-120)
    - Enums with specific choices (e.g., mood: happy/sad/neutral)
    
    For plain strings, just use the key name directly: expects: [user_name]
    """
    key: str
    type: str = "string"  # number, enum (string is default, no validation)
    min: Optional[float] = None  # For numbers: minimum value
    max: Optional[float] = None  # For numbers: maximum value
    choices: Optional[List[str]] = None  # For enums: valid choices
    confirm: bool = False  # If true, requires explicit confirmation flag in state
    
    def validate_value(self, value: str) -> tuple[bool, str]:
        """Validate a value against this definition. Returns (is_valid, error_message)."""
        if self.type == "number":
            try:
                num = float(value)
                if self.min is not None and num < self.min:
                    return False, f"Value {num} is below minimum {self.min}"
                if self.max is not None and num > self.max:
                    return False, f"Value {num} is above maximum {self.max}"
            except ValueError:
                return False, f"'{value}' is not a valid number"
        elif self.type == "enum":
            if self.choices and value.lower() not in [c.lower() for c in self.choices]:
                return False, f"Value must be one of: {', '.join(self.choices)}"
        return True, ""


class TaskDefinition(BaseModel):
    """Task definition from config."""
    description: str
    expects: List[Union[str, ExpectDefinition]] = []
    tools: List[Dict[str, Any]] = []
    silent: bool = False  # If True, don't show assistant_reply (just collect state)
    
    def get_expect_keys(self) -> List[str]:
        """Get just the keys from expects (handles both string and ExpectDefinition)."""
        keys = []
        for exp in self.expects:
            if isinstance(exp, str):
                keys.append(exp)
            else:
                keys.append(exp.key)
        return keys
    
    def get_expect_definition(self, key: str) -> Optional[ExpectDefinition]:
        """Get the ExpectDefinition for a key, or None if it's just a string."""
        for exp in self.expects:
            if isinstance(exp, ExpectDefinition) and exp.key == key:
                return exp
        return None
    
    def validate_value(self, key: str, value: str) -> tuple[bool, str]:
        """Validate a value for a given key. Returns (is_valid, error_message)."""
        exp_def = self.get_expect_definition(key)
        if exp_def:
            return exp_def.validate_value(value)
        return True, ""  # No validation defined


class ToolCall(BaseModel):
    """Tool invocation from LLM."""
    tool: str
    options: Optional[List[str]] = None


class TaskResult(BaseModel):
    """Task execution result from LLM."""
    task_id: str = ""  # Which task this result belongs to (optional for backwards compat)
    key: str
    value: Optional[str] = None  # Allow null values for mandatory extraction entries



class ChatGuideReply(BaseModel):
    """LLM response envelope."""
    assistant_reply: str
    task_results: List[TaskResult] = []
    tools: List[ToolCall] = []
    
    @property
    def text(self) -> str:
        """Alias for assistant_reply (shorter, more intuitive)."""
        return self.assistant_reply


--------------------------------------------------------------------------------

------------------------------------------------------------
FILE: python/chatguide\state.py
CATEGORY: CORE_PACKAGE
STATS: 122 lines, 4,616 bytes
MODIFIED: 2025-12-15 20:20:13
FULL PATH: C:\Users\photo\Desktop\chatguide\python\chatguide\state.py
------------------------------------------------------------

"""State - flat dictionary with template resolution and audit tracking."""

import re
from typing import Any, Dict, Optional

# Avoid circular import - audit will be injected
if False:
    from .core.audit import AuditLog


class State:
    """Flat state dictionary with template resolution and audit tracking.
    
    Central working memory for all variables and outputs.
    Supports Pythonic attribute access: state.user_name instead of state.get("user_name")
    """
    
    def __init__(self, initial: Dict[str, Any] = None, audit_log: Optional["AuditLog"] = None):
        # Use object.__setattr__ to avoid triggering our custom __setattr__
        object.__setattr__(self, '_data', initial or {})
        object.__setattr__(self, '_audit_log', audit_log)
        object.__setattr__(self, '_recent_keys', [])
    
    def get(self, key: str, default=None) -> Any:
        """Get value from state."""
        return self._data.get(key, default)
    
    def set(self, key: str, value: Any, source_task: Optional[str] = None):
        """Set value in state with optional audit logging."""
        old_value = self._data.get(key)
        self._data[key] = value

        # Track recent keys for corrections
        if key not in self._recent_keys:
            self._recent_keys.append(key)

        # Log change if audit is enabled
        if self._audit_log and old_value != value:
            self._audit_log.log(key, old_value, value, source_task)
    
    def update(self, data: Dict[str, Any], source_task: Optional[str] = None):
        """Update state with dictionary."""
        for key, value in data.items():
            self.set(key, value, source_task)

    def get_typed(self, key: str, type_: type, default=None) -> Any:
        """Get value with type checking."""
        val = self._data.get(key, default)
        if val is not None and not isinstance(val, type_):
            try:
                return type_(val)
            except (ValueError, TypeError):
                return default
        return val
    
    def resolve_template(self, template: Any) -> Any:
        """Resolve {{var}} templates in strings, dicts, or lists.
        
        Examples:
            "Hello {{user_name}}" -> "Hello John"
            {"name": "{{user_name}}"} -> {"name": "John"}
            ["{{var1}}", "{{var2}}"] -> ["value1", "value2"]
        """
        if isinstance(template, str):
            return self._resolve_string(template)
        elif isinstance(template, dict):
            return {k: self.resolve_template(v) for k, v in template.items()}
        elif isinstance(template, list):
            return [self.resolve_template(item) for item in template]
        return template
    
    def _resolve_string(self, text: str) -> str:
        """Resolve {{var}} patterns in string."""
        pattern = r'\{\{(\w+)\}\}'
        
        def replacer(match):
            var_name = match.group(1)
            value = self._data.get(var_name)
            return str(value) if value is not None else match.group(0)
        
        return re.sub(pattern, replacer, text)
    
    @property
    def variables(self) -> Dict[str, Any]:
        """Get clean dict of all variables (business data only)."""
        return self._data.copy()

    def get_recent_extractions(self, limit: int = 10) -> list:
        """Get recent extractions as list of {key, value} dicts."""
        recent = self._recent_keys[-limit:]
        return [{"key": k, "value": self._data[k]} for k in recent if k in self._data]

    def to_dict(self) -> Dict[str, Any]:
        """Export state as dict."""
        return {
            "data": self._data.copy(),
            "recent_keys": self._recent_keys.copy()
        }
    
    def __contains__(self, key: str) -> bool:
        """Support 'key in state' syntax."""
        return key in self._data
    
    def __getattr__(self, name: str) -> Any:
        """Support state.variable_name syntax for reading."""
        if name.startswith('_'):
            # Avoid infinite recursion for private attributes
            raise AttributeError(f"'{type(self).__name__}' object has no attribute '{name}'")
        return self._data.get(name)
    
    def __setattr__(self, name: str, value: Any):
        """Support state.variable_name = value syntax for writing."""
        if name.startswith('_'):
            # Private attributes go to __dict__
            object.__setattr__(self, name, value)
        else:
            # Public attributes go to _data with audit logging
            self.set(name, value)
    
    def __repr__(self):
        return f"State({self._data})"



--------------------------------------------------------------------------------

------------------------------------------------------------
FILE: python/chatguide\tool_executor.py
CATEGORY: CORE_PACKAGE
STATS: 60 lines, 1,952 bytes
MODIFIED: 2025-12-14 13:04:37
FULL PATH: C:\Users\photo\Desktop\chatguide\python\chatguide\tool_executor.py
------------------------------------------------------------

"""Tools - simple tool executor."""

from typing import Dict, Any, Optional, Callable


class ToolDefinition:
    """Tool definition with metadata."""
    
    def __init__(self, tool_id: str, type: str, description: str, handler: Optional[Callable] = None):
        self.tool_id = tool_id
        self.type = type
        self.description = description
        self.handler = handler


class ToolRegistry:
    """Registry of available tools."""
    
    def __init__(self):
        self._tools: Dict[str, ToolDefinition] = {}
    
    def register(self, tool_id: str, type: str, description: str, handler: Optional[Callable] = None):
        """Register a tool."""
        self._tools[tool_id] = ToolDefinition(tool_id, type, description, handler)
    
    def get(self, tool_id: str) -> Optional[ToolDefinition]:
        return self._tools.get(tool_id)
    
    def to_dict(self) -> dict:
        return {tid: {"type": t.type, "description": t.description} for tid, t in self._tools.items()}


class ToolExecutor:
    """Simple sync tool executor."""
    
    def __init__(self, registry: ToolRegistry):
        self.registry = registry
    
    def execute(self, tool_id: str, args: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Execute a tool. Returns dict to merge into state, or None."""
        tool = self.registry.get(tool_id)
        if not tool or not tool.handler:
            return None
        
        result = tool.handler(**args)
        return result if isinstance(result, dict) else None


# Global registry
_global_registry = ToolRegistry()


def register_tool(tool_id: str, type: str, description: str, handler: Optional[Callable] = None):
    """Register a tool in global registry."""
    _global_registry.register(tool_id, type, description, handler)


def get_tool_registry() -> ToolRegistry:
    """Get global tool registry."""
    return _global_registry


--------------------------------------------------------------------------------


================================================================================
CATEGORY: BUILDERS
================================================================================

------------------------------------------------------------
FILE: python/chatguide\builders\__init__.py
CATEGORY: BUILDERS
STATS: 1 lines, 15 bytes
MODIFIED: 2025-12-13 16:52:15
FULL PATH: C:\Users\photo\Desktop\chatguide\python\chatguide\builders\__init__.py
------------------------------------------------------------

﻿# Builders


--------------------------------------------------------------------------------

------------------------------------------------------------
FILE: python/chatguide\builders\prompt.py
CATEGORY: BUILDERS
STATS: 274 lines, 9,421 bytes
MODIFIED: 2025-12-15 23:36:56
FULL PATH: C:\Users\photo\Desktop\chatguide\python\chatguide\builders\prompt.py
------------------------------------------------------------

from dataclasses import dataclass
from typing import List, Dict, Any, Optional
import yaml
from pathlib import Path
from ..core.task import Task


# ============================================================
# Prompt View (UNCHANGED)
# ============================================================

@dataclass
class PromptView:
    """View model for prompt generation."""
    current_task: Optional[Task]
    pending_tasks: List[Task]
    completed_tasks: List[str]
    state: Dict[str, Any]
    tone_text: str
    guardrails: str
    history: List[Dict[str, str]]
    language: str = "en"
    next_block_task: Optional[Task] = None  # First task of next block
    recent_extractions: List[Dict[str, Any]] = None  # Last N extractions for corrections


# ============================================================
# Prompt Builder (REFACTORED)
# ============================================================

class PromptBuilder:
    """Builds a clean, structured prompt from config and state."""

    _lang_templates: Dict[str, Dict[str, Any]] = None

    def __init__(self, view: PromptView):
        self.view = view
        if PromptBuilder._lang_templates is None:
            self._load_language_templates()

    # --------------------------------------------------
    # Language templates
    # --------------------------------------------------

    @classmethod
    def _load_language_templates(cls):
        template_path = Path(__file__).parent.parent / "core" / "core_prompt.yaml"
        with open(template_path, "r", encoding="utf-8") as f:
            cls._lang_templates = yaml.safe_load(f)

    def _get_lang(self, key: str, default: str = "") -> str:
        lang_data = self._lang_templates.get(
            self.view.language,
            self._lang_templates.get("en", {})
        )
        return lang_data.get(key, default)

    # --------------------------------------------------
    # Public entry point
    # --------------------------------------------------

    def build(self) -> str:
        sections = [
            self._system_role(),
            self._context_section(),
            self._objective_section(),
            self._response_contract(),
        ]
        return "\n\n".join(s for s in sections if s).strip()

    # ==================================================
    # Prompt sections
    # ==================================================

    def _system_role(self) -> str:
        return self._get_lang(
            "language_instruction",
            """You are a helpful conversational assistant. Follow these guidelines:

CONVERSATIONAL STYLE:
- Respond naturally and vary your acknowledgments (avoid repetitive phrases like "Okay, [name]")
- Keep responses conversational and engaging
- Don't repeat the same acknowledgment patterns
- Transition smoothly between topics

EXTRACTION HANDLING:
- If user gives irrelevant or unextractable information, acknowledge it briefly and rephrase your question
- Don't get stuck repeating the same question - vary your approach
- If user is being difficult or giving nonsense, stay professional and try to redirect
- Progress the conversation even when extraction fails

GENERAL RULES:
- Stay in character and maintain helpful tone
- Be patient with users who give unexpected responses
- Always provide value in your responses"""
        )

    def _context_section(self) -> str:
        return f"""
CONTEXT
-------
Conversation history (reference for context, but vary your responses):
{self._format_history()}

Known facts (verified — do NOT re-ask):
{self._format_state()}

Recent extractions (last values captured — user may correct these):
{self._format_recent_extractions()}

CONVERSATION TIPS:
- Don't repeat the same acknowledgment patterns from history
- If you see repetitive questions in history, try a different approach
- Stay conversational and natural, not robotic
""".strip()

    def _objective_section(self) -> str:
        return f"""
OBJECTIVE
---------
Current task:
{self._format_current_task()}

Next task (after completion):
{self._format_next_task()}

Tone:
{self.view.tone_text}

RESPONSE STRATEGY:
- If you CAN extract the expected information: acknowledge briefly and move forward
- If you CANNOT extract information: acknowledge the user's response naturally, then rephrase and ask again
- Vary your language - don't repeat the same phrases or questions
- Keep the conversation flowing even when extraction fails
- If user gives nonsense/irrelevant answers, acknowledge it lightly and redirect

Output Format:
- task_results: put here all extracted/corrected values from the user's response. If a key already exists in state, overwrite it. Include both new extractions and corrections to recent values.
- tools: if the task requires the use of a tool, add the tool id and options to the tools key.
General:
- After completing the current task, smoothly transition to the next task in the same reply.
""".strip()

    def _response_contract(self) -> str:
        # Get expected keys for current task
        current_task = self.view.current_task
        expected_keys = []
        if current_task and current_task.expects:
            expected_keys = [exp.key for exp in current_task.expects]

        expected_keys_str = ", ".join(f'"{k}"' for k in expected_keys) if expected_keys else "none"

        return f"""
RESPONSE FORMAT
---------------
Respond ONLY with valid JSON:

{{
  "assistant_reply": "Natural response shown to the user",
  "task_results": [
    {{
      "task_id": "task_name",
      "key": "state_variable_name",
      "value": "extracted_value_or_null"
    }}
  ],
  "tools": []
}}

MANDATORY EXTRACTION RULES:
- Expected keys: {expected_keys_str}
- OUTPUT EXACTLY ONE task_result FOR EACH expected key (no more, no less)
- Use value: null if you cannot extract a meaningful value
- NO MISSING task_results entries - every expected key must be present
- NO EXTRA keys - only output keys listed in expected keys
- value can be null but key must be present in task_results

RESPONSE GUIDANCE WHEN EXTRACTION FAILS:
- If all values are null: Provide a natural response acknowledging what user said, then rephrase your question differently
- Don't repeat the same question verbatim - vary your approach
- Stay conversational and engaging even when you can't extract information
- If user is being difficult, remain patient and professional

Constraints:
- assistant_reply: Natural conversational response to user (vary your acknowledgments)
- task_results: One entry per expected key, value can be string or null
- tools: Leave empty array [] (tools not used in minimal v1)
""".strip()

    # ==================================================
    # Formatting helpers (largely preserved)
    # ==================================================

    def _format_history(self) -> str:
        if not self.view.history:
            return self._get_lang("none", "(No messages yet)")

        lines = []
        for msg in self.view.history[-10:]:
            role = msg.get("role", "unknown")
            content = msg.get("content", "")
            lines.append(f"{role}: {content}")

        return "\n".join(lines)

    def _format_state(self) -> str:
        if not self.view.state:
            return self._get_lang("none", "(Empty)")

        return "\n".join(
            f"- {key}: {value}"
            for key, value in self.view.state.items()
        )

    def _format_recent_extractions(self) -> str:
        extractions = self.view.recent_extractions or []
        if not extractions:
            return "(No recent extractions)"

        # Show last 10, most recent last
        last_10 = extractions[-10:]
        return "\n".join(
            f"- {e['key']}: {e['value']}"
            for e in last_10
        )

    def _format_current_task(self) -> str:
        task = self.view.current_task
        if not task:
            return "(no active task)"

        return f"- {task.id}: {task.description}"

    def _format_next_task(self) -> str:
        task = self.view.next_block_task
        if not task:
            return "(no further tasks)"

        return f"- {task.id}: {task.description}"

    def _format_tasks(self) -> str:
        """
        Kept for compatibility if other code still calls it.
        Not used directly in the new prompt layout.
        """
        if not self.view.pending_tasks:
            return self._get_lang("none", "(None)")

        lines = []
        current_task_id = self.view.current_task.id if self.view.current_task else None

        for task in self.view.pending_tasks:
            is_current = (task.id == current_task_id)
            prefix = "(current task)" if is_current else ""
            lines.append(f"Task: {task.id} {prefix}")
            lines.append(f"Description: {task.description}")

            if task.expects:
                expects = []
                for exp in task.expects:
                    if hasattr(exp, "key"):
                        expects.append(exp.key)
                    else:
                        expects.append(str(exp))
                lines.append(f"Expected to collect: {', '.join(expects)}")

            if task.tools:
                lines.append("Available tools:")
                for tool_def in task.tools:
                    lines.append(f"  - {tool_def.get('tool', 'unknown')}")

            lines.append("")

        return "\n".join(lines).strip()


--------------------------------------------------------------------------------


================================================================================
CATEGORY: CORE_ENGINE
================================================================================

------------------------------------------------------------
FILE: python/chatguide\core\__init__.py
CATEGORY: CORE_ENGINE
STATS: 9 lines, 249 bytes
MODIFIED: 2025-12-14 09:55:45
FULL PATH: C:\Users\photo\Desktop\chatguide\python\chatguide\core\__init__.py
------------------------------------------------------------

﻿"""Core components."""

from .execution import ExecutionState
from .context import Context
from .audit import AuditLog
from .task import Task
from .block import Block

__all__ = ["ExecutionState", "Context", "AuditLog", "Task", "Block"]


--------------------------------------------------------------------------------

------------------------------------------------------------
FILE: python/chatguide\core\audit.py
CATEGORY: CORE_ENGINE
STATS: 84 lines, 2,495 bytes
MODIFIED: 2025-12-13 17:00:39
FULL PATH: C:\Users\photo\Desktop\chatguide\python\chatguide\core\audit.py
------------------------------------------------------------

"""AuditLog - append-only change tracking."""

from typing import List, Dict, Any, Optional
from datetime import datetime
from dataclasses import dataclass, asdict


@dataclass
class AuditEntry:
    """Single audit log entry."""
    timestamp: str
    key: str
    old_value: Any
    new_value: Any
    source_task: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)


class AuditLog:
    """Append-only log of all state changes."""
    
    def __init__(self):
        self._entries: List[AuditEntry] = []
    
    def log(self, key: str, old_value: Any, new_value: Any, source_task: Optional[str] = None):
        """Log a state change."""
        entry = AuditEntry(
            timestamp=datetime.now().isoformat(),
            key=key,
            old_value=old_value,
            new_value=new_value,
            source_task=source_task
        )
        self._entries.append(entry)
    
    def search(
        self, 
        key: Optional[str] = None, 
        task: Optional[str] = None,
        since: Optional[str] = None
    ) -> List[Dict[str, Any]]:
        """Search audit log with filters.
        
        Args:
            key: Filter by state key
            task: Filter by source task
            since: Filter by timestamp (ISO format)
        
        Returns:
            List of matching audit entries
        """
        results = self._entries
        
        if key:
            results = [e for e in results if e.key == key]
        
        if task:
            results = [e for e in results if e.source_task == task]
        
        if since:
            results = [e for e in results if e.timestamp >= since]
        
        return [e.to_dict() for e in results]
    
    def get_latest(self, key: str) -> Optional[Dict[str, Any]]:
        """Get the most recent change for a key."""
        entries = [e for e in self._entries if e.key == key]
        if entries:
            return entries[-1].to_dict()
        return None
    
    def to_list(self) -> List[Dict[str, Any]]:
        """Export all entries as list."""
        return [e.to_dict() for e in self._entries]
    
    @classmethod
    def from_list(cls, data: List[Dict[str, Any]]) -> "AuditLog":
        """Restore audit log from list."""
        log = cls()
        for entry_data in data:
            log._entries.append(AuditEntry(**entry_data))
        return log


--------------------------------------------------------------------------------

------------------------------------------------------------
FILE: python/chatguide\core\block.py
CATEGORY: CORE_ENGINE
STATS: 37 lines, 1,246 bytes
MODIFIED: 2025-12-13 17:00:39
FULL PATH: C:\Users\photo\Desktop\chatguide\python\chatguide\core\block.py
------------------------------------------------------------

"""Block object representing a group of tasks."""

from typing import List, Dict, Any
from .task import Task

class Block:
    """Represents a group of tasks that can be executed together."""
    
    def __init__(self, tasks: List[Task]):
        self.tasks = tasks
        
    @property
    def task_ids(self) -> List[str]:
        """Get list of task IDs in this block."""
        return [t.id for t in self.tasks]
        
    def is_complete(self) -> bool:
        """Check if all tasks in block are complete."""
        return all(t.is_completed() for t in self.tasks)
        
    def get_pending_tasks(self) -> List[Task]:
        """Get tasks that are not yet completed."""
        return [t for t in self.tasks if not t.is_completed()]
        
    def get_task(self, task_id: str) -> Task:
        """Get task by ID if it exists in this block."""
        for task in self.tasks:
            if task.id == task_id:
                return task
        return None
        
    def to_dict(self) -> Dict[str, Any]:
        """Serialize block."""
        return {
            "tasks": [t.to_dict() for t in self.tasks],
            "status": "completed" if self.is_complete() else "pending"
        }


--------------------------------------------------------------------------------

------------------------------------------------------------
FILE: python/chatguide\core\context.py
CATEGORY: CORE_ENGINE
STATS: 69 lines, 2,445 bytes
MODIFIED: 2025-12-15 20:20:13
FULL PATH: C:\Users\photo\Desktop\chatguide\python\chatguide\core\context.py
------------------------------------------------------------

"""Context - manages conversation history and session metadata."""

from typing import List, Dict, Any, Optional
from datetime import datetime


class Message:
    """Represents a single message in the conversation."""
    
    def __init__(self, role: str, content: str, timestamp: Optional[str] = None):
        self.role = role
        self.content = content
        self.timestamp = timestamp or datetime.now().isoformat()
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "role": self.role,
            "content": self.content,
            "timestamp": self.timestamp
        }


class Context:
    """Manages conversation history and session metadata."""
    
    def __init__(self, session_id: Optional[str] = None, metadata: Optional[Dict[str, Any]] = None):
        self.session_id = session_id
        self.metadata = metadata or {}
        self._history: List[Message] = []
        self.created_at = datetime.now().isoformat()
    
    @property
    def history(self) -> List[Message]:
        """Get conversation history."""
        return self._history
    
    def add_message(self, role: str, content: str):
        """Add a message to history."""
        if role not in ("user", "assistant"):
            raise ValueError(f"Invalid role: {role}. Must be 'user' or 'assistant'.")
        self._history.append(Message(role, content))
    
    def get_history_dict(self) -> List[Dict[str, str]]:
        """Get history as list of dicts (for LLM prompts)."""
        return [{"role": msg.role, "content": msg.content} for msg in self._history]
    
    def to_dict(self) -> Dict[str, Any]:
        """Export context as dict."""
        return {
            "session_id": self.session_id,
            "metadata": self.metadata,
            "history": [msg.to_dict() for msg in self._history],
            "created_at": self.created_at
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Context":
        """Restore context from dict."""
        ctx = cls(session_id=data.get("session_id"), metadata=data.get("metadata", {}))
        ctx.created_at = data.get("created_at", datetime.now().isoformat())
        
        for msg_data in data.get("history", []):
            ctx._history.append(Message(
                role=msg_data["role"],
                content=msg_data["content"],
                timestamp=msg_data.get("timestamp")
            ))
        
        return ctx


--------------------------------------------------------------------------------

------------------------------------------------------------
FILE: python/chatguide\core\execution.py
CATEGORY: CORE_ENGINE
STATS: 88 lines, 3,023 bytes
MODIFIED: 2025-12-15 20:20:13
FULL PATH: C:\Users\photo\Desktop\chatguide\python\chatguide\core\execution.py
------------------------------------------------------------

from enum import Enum
from typing import Dict, Any, Optional, Union

class ExecStatus(str, Enum):
    IDLE = "idle"
    PROCESSING = "processing"
    # Legacy 'awaiting_input' map to WAITING_USER? Or just use awaiting_input as value?
    # Checklist said: WAITING_USER. I'll use that but support alias.
    WAITING_USER = "awaiting_input" 
    WAITING_TOOL = "waiting_tool"
    COMPLETE = "complete"
    ERROR = "error"

class ExecutionState:
    """Tracks the current position in the conversation flow.
    
    Note: Pending UI tools are managed by ToolExecutor (single source of truth).
    """
    
    def __init__(self):
        self._current_task: Optional[str] = None
        self._status: ExecStatus = ExecStatus.IDLE
    
    @property
    def current_task(self) -> Optional[str]:
        """Get current task ID."""
        return self._current_task
    
    @current_task.setter
    def current_task(self, task_id: Optional[str]):
        """Set current task ID."""
        self._current_task = task_id
    
    @property
    def status(self) -> str:
        """Get execution status."""
        return self._status.value
    
    @status.setter
    def status(self, value: Union[str, ExecStatus]):
        """Set execution status."""
        # Only enforce strict transitions in debug mode
        if self._status == ExecStatus.COMPLETE and value != ExecStatus.COMPLETE:
            if __debug__:
                raise ValueError("Cannot transition from COMPLETE")
            return  # Silently ignore in production
        
        if isinstance(value, ExecStatus):
            self._status = value
            return
            
        try:
            self._status = ExecStatus(value)
        except ValueError:
            # Handle legacy/check list divergence
            if value == "waiting_user":
                self._status = ExecStatus.WAITING_USER
            else:
                if __debug__:
                    raise ValueError(f"Invalid status: {value}")
                # Silently ignore invalid status in production
    
    def progress(self, completed_count: int, total_tasks: int) -> Dict[str, Any]:
        """Calculate progress metrics."""
        percent = int((completed_count / total_tasks * 100)) if total_tasks > 0 else 0
        
        return {
            "completed": completed_count,
            "total": total_tasks,
            "percent": percent,
            "current_task": self._current_task
        }
    
    def to_dict(self) -> Dict[str, Any]:
        """Export execution state as dict."""
        return {
            "current_task": self._current_task,
            "status": self._status.value
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "ExecutionState":
        """Restore execution state from dict."""
        state = cls()
        state._current_task = data.get("current_task")
        # Ignore pending_tools from old checkpoints (ephemeral UI state)
        state.status = data.get("status", "idle")
        return state


--------------------------------------------------------------------------------

------------------------------------------------------------
FILE: python/chatguide\core\task.py
CATEGORY: CORE_ENGINE
STATS: 91 lines, 3,207 bytes
MODIFIED: 2025-12-15 20:20:13
FULL PATH: C:\Users\photo\Desktop\chatguide\python\chatguide\core\task.py
------------------------------------------------------------

"""Task object representing a unit of work."""

from typing import List, Dict, Any, Optional
from dataclasses import dataclass, field

@dataclass
class Task:
    """Represents a single task in the conversation plan."""
    
    id: str
    description: str
    expects: List[str] = field(default_factory=list)
    tools: List[Dict[str, Any]] = field(default_factory=list)
    silent: bool = False
    
    # Runtime state
    status: str = "pending"  # pending, in_progress, completed
    result: Optional[Dict[str, Any]] = None
    
    def complete(self, key: str, value: Any):
        """Mark task as complete with extracted value."""
        if self.status == "completed":
            return
        self.status = "completed"
        self.result = {"key": key, "value": value}
        
    def is_completed(self) -> bool:
        """Check if task is completed."""
        return self.status == "completed"

    def get_expected_keys(self) -> List[str]:
        """Get list of state keys this task expects.
        
        All expects are normalized to ExpectDefinition objects at load time.
        """
        return [exp.key for exp in self.expects]

    def validate(self, key: str, value: Any) -> tuple[bool, str]:
        """Validate a value against expectations.
        
        Returns (False, error) if:
        - Key is not in expects (unexpected key)
        - Value fails validation rules
        """
        for exp in self.expects:
            # Check if this expectation matches the key
            exp_key = None
            if isinstance(exp, str):
                exp_key = exp
            elif isinstance(exp, dict):
                exp_key = exp.get("key")
            elif hasattr(exp, "key"):
                exp_key = exp.key
            
            if exp_key == key:
                # Found the expectation, validation depends on type
                if hasattr(exp, 'validate_value'):
                    return exp.validate_value(value)
                return True, ""
        
        # Key not in expects - accept it (don't be overly strict)
        return True, ""
    
    def to_dict(self) -> Dict[str, Any]:
        """Serialize task state."""
        # Serialize expects if they are objects (ExpectDefinition)
        serialized_expects = []
        for exp in self.expects:
            if hasattr(exp, 'model_dump'):
                serialized_expects.append(exp.model_dump())
            elif hasattr(exp, 'dict'):
                serialized_expects.append(exp.dict())
            elif isinstance(exp, dict):
                serialized_expects.append(exp)
            elif isinstance(exp, str):
                serialized_expects.append(exp)
            elif hasattr(exp, '__dict__'):
                serialized_expects.append(exp.__dict__)
            else:
                # Fallback to string to prevent JSON serialization errors
                serialized_expects.append(str(exp))

        return {
            "id": self.id,
            "description": self.description,
            "expects": serialized_expects,
            "tools": self.tools,
            "silent": self.silent,
            "status": self.status,
            "result": self.result
        }


--------------------------------------------------------------------------------


================================================================================
CATEGORY: IO_LAYER
================================================================================

------------------------------------------------------------
FILE: python/chatguide\io\__init__.py
CATEGORY: IO_LAYER
STATS: 1 lines, 9 bytes
MODIFIED: 2025-12-13 16:52:15
FULL PATH: C:\Users\photo\Desktop\chatguide\python\chatguide\io\__init__.py
------------------------------------------------------------

﻿# IO


--------------------------------------------------------------------------------

------------------------------------------------------------
FILE: python/chatguide\io\llm.py
CATEGORY: IO_LAYER
STATS: 104 lines, 3,586 bytes
MODIFIED: 2025-12-14 10:31:50
FULL PATH: C:\Users\photo\Desktop\chatguide\python\chatguide\io\llm.py
------------------------------------------------------------

from __future__ import annotations

"""Multi-provider LLM dispatcher; isolates third-party SDKs from core logic."""

from typing import Any, Optional

__all__ = ["run_llm"]


from dataclasses import dataclass

@dataclass
class TokenUsage:
    prompt: int = 0
    completion: int = 0

@dataclass
class LLMResult:
    content: Any  # str or dict/object
    usage: TokenUsage

def run_llm(
    prompt: str,
    *,
    model: str = "gemini/gemini-2.5-flash-lite",
    api_key: Optional[str] = None,
    temperature: float = 0.6,
    max_tokens: int = 256,
    extra_config: Optional[dict[str, Any]] = None,
) -> LLMResult:
    """Route to the correct provider based on model string prefix.
    
    Expected format: "provider/model_name"
    Examples:
        - "gemini/gemini-2.5-flash-lite"
        - "openai/gpt-4"
        - "anthropic/claude-3-5-sonnet"
    """
    if "/" not in model:
        raise ValueError(f"Model must be in format 'provider/model_name', got: {model}")
    
    provider, model_name = model.split("/", 1)
    
    if provider == "gemini":
        return _run_gemini(prompt, model=model_name, api_key=api_key,
                          temperature=temperature, max_tokens=max_tokens,
                          extra_config=extra_config)
    elif provider == "openai":
        return _run_openai(prompt, model=model_name, api_key=api_key,
                          temperature=temperature, max_tokens=max_tokens,
                          extra_config=extra_config)
    elif provider == "anthropic":
        return _run_anthropic(prompt, model=model_name, api_key=api_key,
                             temperature=temperature, max_tokens=max_tokens,
                             extra_config=extra_config)
    else:
        raise NotImplementedError(f"Provider '{provider}' not supported")


# -----------------------------------------------------------------------------
# Provider implementations
# -----------------------------------------------------------------------------

def _run_gemini(prompt: str, *, model: str, api_key: Optional[str],
                temperature: float, max_tokens: int,
                extra_config: Optional[dict[str, Any]]) -> LLMResult:
    from google import genai
    
    client = genai.Client(api_key=api_key)
    cfg = {
        "response_mime_type": "application/json",
        "temperature": temperature,
        "max_output_tokens": max_tokens,
    }
    if extra_config:
        cfg.update(extra_config)

    resp = client.models.generate_content(
        model=model,
        contents=prompt,
        config=cfg,
    )
    
    content = getattr(resp, "parsed", None) or getattr(resp, "text", None)
    
    # Extract usage
    usage = TokenUsage()
    if hasattr(resp, "usage_metadata"):
        usage.prompt = resp.usage_metadata.prompt_token_count
        usage.completion = resp.usage_metadata.candidates_token_count
        
    return LLMResult(content=content, usage=usage)


def _run_openai(prompt: str, *, model: str, api_key: Optional[str],
                temperature: float, max_tokens: int,
                extra_config: Optional[dict[str, Any]]) -> LLMResult:
    raise NotImplementedError("OpenAI provider not yet implemented")


def _run_anthropic(prompt: str, *, model: str, api_key: Optional[str],
                   temperature: float, max_tokens: int,
                   extra_config: Optional[dict[str, Any]]) -> LLMResult:
    raise NotImplementedError("Anthropic provider not yet implemented")


--------------------------------------------------------------------------------

------------------------------------------------------------
FILE: python/chatguide\io\storage.py
CATEGORY: IO_LAYER
STATS: 146 lines, 5,288 bytes
MODIFIED: 2025-12-13 16:52:15
FULL PATH: C:\Users\photo\Desktop\chatguide\python\chatguide\io\storage.py
------------------------------------------------------------

"""Storage adapters for persisting conversation state."""

from typing import Dict, Any, Optional
import json


class StorageAdapter:
    """Base class for storage adapters."""
    
    def save(self, conversation_id: str, state_dict: Dict[str, Any]):
        """Save conversation state."""
        raise NotImplementedError
    
    def load(self, conversation_id: str) -> Optional[Dict[str, Any]]:
        """Load conversation state."""
        raise NotImplementedError
    
    def delete(self, conversation_id: str):
        """Delete conversation state."""
        raise NotImplementedError


class SupabaseStorage(StorageAdapter):
    """Store conversation state in Supabase.
    
    Usage:
        storage = SupabaseStorage(url, key, table="conversations")
        
        # Save
        storage.save("user_123", guide.get_state())
        
        # Load
        state_dict = storage.load("user_123")
        # Then restore state from dict
    """
    
    def __init__(self, supabase_url: str, supabase_key: str, table: str = "conversations"):
        """Initialize Supabase storage.
        
        Args:
            supabase_url: Your Supabase project URL
            supabase_key: Your Supabase anon/service key
            table: Table name for storing conversations
        """
        try:
            from supabase import create_client
            self.client = create_client(supabase_url, supabase_key)
            self.table = table
        except ImportError:
            raise ImportError("Supabase not installed. Run: pip install supabase")
    
    def save(self, conversation_id: str, state_dict: Dict[str, Any]):
        """Save conversation state to Supabase."""
        data = {
            "id": conversation_id,
            "state": json.dumps(state_dict),
            "updated_at": "now()"
        }
        
        # Upsert (insert or update)
        self.client.table(self.table).upsert(data).execute()
    
    def load(self, conversation_id: str) -> Optional[Dict[str, Any]]:
        """Load conversation state from Supabase."""
        result = self.client.table(self.table).select("state").eq("id", conversation_id).execute()
        
        if result.data and len(result.data) > 0:
            return json.loads(result.data[0]["state"])
        return None
    
    def delete(self, conversation_id: str):
        """Delete conversation from Supabase."""
        self.client.table(self.table).delete().eq("id", conversation_id).execute()


class RedisStorage(StorageAdapter):
    """Store conversation state in Redis.
    
    Usage:
        storage = RedisStorage(host="localhost", port=6379)
        storage.save("user_123", guide.get_state())
    """
    
    def __init__(self, host: str = "localhost", port: int = 6379, db: int = 0, 
                 key_prefix: str = "chatguide:"):
        """Initialize Redis storage."""
        try:
            import redis
            self.client = redis.Redis(host=host, port=port, db=db, decode_responses=True)
            self.key_prefix = key_prefix
        except ImportError:
            raise ImportError("Redis not installed. Run: pip install redis")
    
    def save(self, conversation_id: str, state_dict: Dict[str, Any]):
        """Save conversation state to Redis."""
        key = f"{self.key_prefix}{conversation_id}"
        self.client.set(key, json.dumps(state_dict))
    
    def load(self, conversation_id: str) -> Optional[Dict[str, Any]]:
        """Load conversation state from Redis."""
        key = f"{self.key_prefix}{conversation_id}"
        data = self.client.get(key)
        if data:
            return json.loads(data)
        return None
    
    def delete(self, conversation_id: str):
        """Delete conversation from Redis."""
        key = f"{self.key_prefix}{conversation_id}"
        self.client.delete(key)


class FileStorage(StorageAdapter):
    """Store conversation state in local JSON files.
    
    Usage:
        storage = FileStorage(directory="conversations")
        storage.save("user_123", guide.get_state())
    """
    
    def __init__(self, directory: str = "conversations"):
        """Initialize file storage."""
        from pathlib import Path
        self.directory = Path(directory)
        self.directory.mkdir(exist_ok=True)
    
    def save(self, conversation_id: str, state_dict: Dict[str, Any]):
        """Save conversation state to file."""
        file_path = self.directory / f"{conversation_id}.json"
        with open(file_path, 'w', encoding='utf-8') as f:
            json.dump(state_dict, f, indent=2, ensure_ascii=False)
    
    def load(self, conversation_id: str) -> Optional[Dict[str, Any]]:
        """Load conversation state from file."""
        file_path = self.directory / f"{conversation_id}.json"
        if file_path.exists():
            with open(file_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        return None
    
    def delete(self, conversation_id: str):
        """Delete conversation file."""
        file_path = self.directory / f"{conversation_id}.json"
        if file_path.exists():
            file_path.unlink()



--------------------------------------------------------------------------------


================================================================================
CATEGORY: TOOLS
================================================================================

------------------------------------------------------------
FILE: python/chatguide\tools\__init__.py
CATEGORY: TOOLS
STATS: 1 lines, 73 bytes
MODIFIED: 2025-12-13 16:52:15
FULL PATH: C:\Users\photo\Desktop\chatguide\python\chatguide\tools\__init__.py
------------------------------------------------------------

"""HTML tool definitions - tools are registered in main __init__.py."""


--------------------------------------------------------------------------------

------------------------------------------------------------
FILE: python/chatguide\tools\html\__init__.py
CATEGORY: TOOLS
STATS: 2 lines, 38 bytes
MODIFIED: 2025-12-13 16:52:15
FULL PATH: C:\Users\photo\Desktop\chatguide\python\chatguide\tools\html\__init__.py
------------------------------------------------------------

"""HTML interactive components."""



--------------------------------------------------------------------------------


================================================================================
CATEGORY: UTILITIES
================================================================================

------------------------------------------------------------
FILE: python/chatguide\utils\__init__.py
CATEGORY: UTILITIES
STATS: 1 lines, 12 bytes
MODIFIED: 2025-12-13 16:52:15
FULL PATH: C:\Users\photo\Desktop\chatguide\python\chatguide\utils\__init__.py
------------------------------------------------------------

﻿# Utils


--------------------------------------------------------------------------------

------------------------------------------------------------
FILE: python/chatguide\utils\config_loader.py
CATEGORY: UTILITIES
STATS: 325 lines, 13,711 bytes
MODIFIED: 2025-12-15 23:15:15
FULL PATH: C:\Users\photo\Desktop\chatguide\python\chatguide\utils\config_loader.py
------------------------------------------------------------

"""Config loader - parses YAML configuration files."""

import yaml
from pathlib import Path
from typing import Dict, Any, List, Union
from ..schemas import TaskDefinition, ExpectDefinition
from ..adjustments import (
    Adjustment, Action, PlanJump, PlanInsertBlock, PlanRemoveBlock,
    PlanReplaceBlock, ToneSet, ToneAdd, StateSet
)


def load_config_file(path: str) -> dict:
    """Load YAML config file with better error handling."""
    config_path = Path(path)
    try:
        if not config_path.exists():
            raise FileNotFoundError(f"Config file not found: {path}")

        with open(config_path, 'r', encoding='utf-8') as f:
            content = f.read()

        # Check if file is empty
        if not content.strip():
            raise ValueError(f"Config file is empty: {path}")

        try:
            data = yaml.safe_load(content)
            if data is None:
                raise ValueError(f"Config file contains no valid YAML data: {path}")
            return data
        except yaml.YAMLError as e:
            line_info = ""
            if hasattr(e, 'problem_mark') and e.problem_mark:
                line_info = f" at line {e.problem_mark.line + 1}, column {e.problem_mark.column + 1}"
            raise ValueError(f"Invalid YAML syntax in config file '{path}'{line_info}: {e.problem}")

    except FileNotFoundError:
        raise FileNotFoundError(f"Config file not found: {path}")
    except PermissionError:
        raise PermissionError(f"Permission denied reading config file: {path}")
    except UnicodeDecodeError as e:
        raise ValueError(f"Config file encoding error in '{path}': {e}")
    except Exception as e:
        raise ValueError(f"Error loading config file '{path}': {e}")


def parse_state(data: dict) -> Dict[str, Any]:
    """Parse initial state from config."""
    return data.get("state", {})


def parse_plan(data: dict) -> List[List[str]]:
    """Parse plan (task blocks) from config."""
    return data.get("plan", [])


def parse_tasks(data: dict) -> Dict[str, TaskDefinition]:
    """Parse task definitions from config."""
    tasks = {}
    for task_id, task_data in data.get("tasks", {}).items():
        tasks[task_id] = TaskDefinition(
            description=task_data.get("description", ""),
            expects=task_data.get("expects", []),
            tools=task_data.get("tools", []),
            silent=task_data.get("silent", False)
        )
    return tasks


def parse_tools(data: dict) -> Dict[str, Dict[str, Any]]:
    """Parse tool definitions from config."""
    return data.get("tools", {})


def parse_adjustments(data: dict) -> List[Adjustment]:
    """Parse adjustments from config."""
    adjustments = []
    for adj_data in data.get("adjustments", []):
        name = adj_data.get("name", "unnamed")
        condition = adj_data.get("when", "False")
        actions = adj_data.get("actions", [])
        
        # Convert actions to full format / objects
        formatted_actions = []
        for action in actions:
            if isinstance(action, str):
                # Parse shorthand like "plan.remove_block(1)"
                obj = _parse_action_string(action)
                if obj:
                    formatted_actions.append(obj)
            elif isinstance(action, dict):
                formatted_actions.append(_dict_to_action(action))
        
        adjustments.append(Adjustment(name, condition, formatted_actions))
    
    return adjustments


def _dict_to_action(d: Dict[str, Any]) -> Any:
    """Convert dict action to Action object."""
    t = d.get("type")
    if t == "plan.jump_to":
        return PlanJump(index=d.get("index", 0))
    elif t == "plan.remove_block":
        return PlanRemoveBlock(index=d.get("index", 0))
    elif t == "plan.insert_block":
        return PlanInsertBlock(index=d.get("index", 0), tasks=d.get("tasks", []))
    elif t == "plan.replace_block":
        return PlanReplaceBlock(index=d.get("index", 0), tasks=d.get("tasks", []))
    elif t == "tone.set":
        return ToneSet(tones=d.get("tones", []))
    elif t == "tone.add":
        return ToneAdd(tone=d.get("tone", ""))
    elif t == "state.set":
        return StateSet(key=d.get("key", ""), value=d.get("value"))
    return d


def _parse_action_string(action_str: str) -> Any:
    """Parse action strings like 'plan.remove_block(1)' into Action objects."""
    import re
    import ast
    
    # Match pattern: object.method(args)
    match = re.match(r'(\w+)\.(\w+)\((.*)\)', action_str)
    if not match:
        return None
    
    obj, method, args_str = match.groups()
    action_type = f"{obj}.{method}"
    
    # Parse args
    args = {}
    if args_str:
        try:
            # Evaluate args safely
            args_str = args_str.strip()
            if args_str.startswith('[') or args_str.startswith('{'):
                # List or dict
                evaluated = ast.literal_eval(args_str)
                if action_type == "tone.set":
                    args["tones"] = evaluated
                elif action_type in ["plan.insert_block", "plan.replace_block"]:
                    args["tasks"] = evaluated
            else:
                # Single value (usually index)
                args["index"] = int(args_str)
        except Exception as e:
            if __debug__:
                raise ValueError(f"Invalid adjustment action: {action_str}") from e
            # Silently ignore in production
    
    # Construct object
    if action_type == "plan.jump_to":
        return PlanJump(index=args.get("index", 0))
    elif action_type == "plan.remove_block":
        return PlanRemoveBlock(index=args.get("index", 0))
    elif action_type == "plan.insert_block":
        return PlanInsertBlock(index=args.get("index", 0), tasks=args.get("tasks", []))
    elif action_type == "plan.replace_block":
        return PlanReplaceBlock(index=args.get("index", 0), tasks=args.get("tasks", []))
    elif action_type == "tone.set":
        return ToneSet(tones=args.get("tones", []))
    elif action_type == "tone.add":
        # Argument for tone.add("warm") is strictly a string, not index
        # But regex parsing put it in 'args_str'. 
        # For 'tone.add("warm")', eval would return "warm".
        # Let's fix eval usage for single string
        if args_str and (args_str.startswith('"') or args_str.startswith("'")):
             try:
                 val = ast.literal_eval(args_str)
                 return ToneAdd(tone=val)
             except:
                 pass
        return ToneAdd(tone=args_str) # Fallback
    
    return {"type": action_type, **args} # Fallback legacy dict


def parse_tone(data: dict) -> List[str]:
    """Parse initial tone from config."""
    return data.get("tone", [])


def parse_tones(data: dict) -> Dict[str, str]:
    """Parse tone definitions from config."""
    tones = {}
    for tone_id, tone_data in data.get("tones", {}).items():
        if isinstance(tone_data, dict):
            tones[tone_id] = tone_data.get("description", "")
        else:
            tones[tone_id] = tone_data
    return tones


def parse_guardrails(data: dict) -> str:
    """Parse guardrails from config."""
    guardrails = data.get("guardrails", {})
    if isinstance(guardrails, list):
        return "\n".join(f"- {g}" for g in guardrails)
    elif isinstance(guardrails, dict):
        # Format as key: value pairs
        return "\n".join(f"- {key}: {value}" for key, value in guardrails.items())
    return str(guardrails)


def validate_config(data: dict) -> List[str]:
    """Validate config structure and return list of error messages."""
    errors = []

    # Validate plan
    plan = data.get("plan", [])
    if not isinstance(plan, list):
        errors.append("plan must be a list of task blocks")
    else:
        for i, block in enumerate(plan):
            if not isinstance(block, list):
                errors.append(f"plan[{i}] must be a list of task IDs")
            else:
                for j, task_id in enumerate(block):
                    if not isinstance(task_id, str):
                        errors.append(f"plan[{i}][{j}] must be a string task ID")

    # Validate tasks
    tasks = data.get("tasks", {})
    if not isinstance(tasks, dict):
        errors.append("tasks must be a dictionary")
    else:
        for task_id, task_def in tasks.items():
            if not isinstance(task_def, dict):
                errors.append(f"tasks.{task_id} must be a dictionary")
                continue

            # Validate description
            if "description" not in task_def:
                errors.append(f"tasks.{task_id} must have a 'description' field")
            elif not isinstance(task_def["description"], str):
                errors.append(f"tasks.{task_id}.description must be a string")

            # Validate expects format - CANONICAL FORMAT ONLY
            expects = task_def.get("expects", [])
            if not isinstance(expects, list):
                errors.append(f"tasks.{task_id}.expects must be a list")
            else:
                if not expects:
                    # Empty expects list is OK (no extraction needed)
                    pass
                else:
                    # All expects must be dict objects with "key" field
                    for k, exp in enumerate(expects):
                        if not isinstance(exp, dict):
                            errors.append(f"tasks.{task_id}.expects[{k}] must be a dict object, not a string. Use {{'key': '{exp}'}} instead of '{exp}'")
                        elif "key" not in exp:
                            errors.append(f"tasks.{task_id}.expects[{k}] missing required 'key' field")
                        elif not isinstance(exp["key"], str):
                            errors.append(f"tasks.{task_id}.expects[{k}].key must be a string")
                        else:
                            # Validate type if present
                            exp_type = exp.get("type", "string")
                            if exp_type not in ["string", "number", "enum"]:
                                errors.append(f"tasks.{task_id}.expects[{k}].type must be 'string', 'number', or 'enum'")

                            if exp_type == "number":
                                if "min" in exp and not isinstance(exp["min"], (int, float)):
                                    errors.append(f"tasks.{task_id}.expects[{k}].min must be a number")
                                if "max" in exp and not isinstance(exp["max"], (int, float)):
                                    errors.append(f"tasks.{task_id}.expects[{k}].max must be a number")
                            elif exp_type == "enum":
                                if "choices" not in exp:
                                    errors.append(f"tasks.{task_id}.expects[{k}] with type 'enum' must have 'choices' field")
                                elif not isinstance(exp["choices"], list):
                                    errors.append(f"tasks.{task_id}.expects[{k}].choices must be a list")
                                else:
                                    for choice in exp["choices"]:
                                        if not isinstance(choice, str):
                                            errors.append(f"tasks.{task_id}.expects[{k}].choices must contain only strings")

            # Validate silent flag
            if "silent" in task_def and not isinstance(task_def["silent"], bool):
                errors.append(f"tasks.{task_id}.silent must be a boolean")

    # Validate tones
    tones = data.get("tones", {})
    if not isinstance(tones, dict):
        errors.append("tones must be a dictionary")
    else:
        for tone_id, tone_def in tones.items():
            if isinstance(tone_def, dict):
                if "description" not in tone_def:
                    errors.append(f"tones.{tone_id} must have a 'description' field")
                elif not isinstance(tone_def["description"], str):
                    errors.append(f"tones.{tone_id}.description must be a string")
            elif not isinstance(tone_def, str):
                errors.append(f"tones.{tone_id} must be a string or object with description")

    # Validate tone reference
    tone_refs = data.get("tone", [])
    if not isinstance(tone_refs, list):
        errors.append("tone must be a list of tone IDs")
    else:
        for tone_ref in tone_refs:
            if not isinstance(tone_ref, str):
                errors.append("tone list must contain only strings")
            elif tone_ref not in tones:
                errors.append(f"tone '{tone_ref}' not defined in tones section")

    # Check for referenced but undefined tasks
    defined_tasks = set(tasks.keys())
    for block in plan:
        if isinstance(block, list):
            for task_id in block:
                if isinstance(task_id, str) and task_id not in defined_tasks:
                    errors.append(f"plan references undefined task '{task_id}'")

    return errors


def normalize_expects(expects: List[dict]) -> List[ExpectDefinition]:
    """Normalize expects format to ExpectDefinition objects (canonical format only)."""
    normalized = []
    for exp in expects:
        # All expects should be dict objects at this point (validated)
        normalized.append(ExpectDefinition(**exp))
    return normalized


--------------------------------------------------------------------------------

------------------------------------------------------------
FILE: python/chatguide\utils\debug_formatter.py
CATEGORY: UTILITIES
STATS: 181 lines, 6,983 bytes
MODIFIED: 2025-12-13 16:52:15
FULL PATH: C:\Users\photo\Desktop\chatguide\python\chatguide\utils\debug_formatter.py
------------------------------------------------------------

"""Debug output formatter - beautiful console display."""

from typing import Dict, Any


class ResponseFormatter:
    """Formats AI responses beautifully."""
    
    @staticmethod
    def format_reply(reply, show_tasks: bool = True) -> str:
        """Format ChatGuideReply beautifully.
        
        Args:
            reply: ChatGuideReply object
            show_tasks: If True, show task breakdown
        """
        lines = []
        lines.append("")
        lines.append("=" * 70)
        lines.append("  AI RESPONSE")
        lines.append("=" * 70)
        
        # Assistant reply (full, no truncation)
        lines.append("")
        lines.append("MESSAGE:")
        lines.append(reply.assistant_reply)
        
        if show_tasks:
            # Batch tasks
            if reply.tasks:
                lines.append("")
                lines.append("BATCH TASKS:")
                for task in reply.tasks:
                    if task.result:
                        result_preview = task.result if len(task.result) <= 50 else task.result[:47] + "..."
                        lines.append(f"  [x] {task.task_id} = \"{result_preview}\"")
                    else:
                        lines.append(f"  [ ] {task.task_id} = (empty)")
            
            # Persistent tasks
            if reply.persistent_tasks:
                lines.append("")
                lines.append("PERSISTENT TASKS:")
                for task in reply.persistent_tasks:
                    if task.result:
                        result_preview = task.result if len(task.result) <= 50 else task.result[:47] + "..."
                        lines.append(f"  [*] {task.task_id} = \"{result_preview}\"")
        
        lines.append("")
        lines.append("=" * 70)
        
        return "\n".join(lines)


class DebugFormatter:
    """Formats debug information in a readable, beautiful way."""
    
    @staticmethod
    def format_state(state_dict: Dict[str, Any], show_prompt: bool = False, 
                     prompt: str = "") -> str:
        """Format state dictionary into beautiful output.
        
        Args:
            state_dict: Output from state.to_dict()
            show_prompt: If True, include full prompt
            prompt: The prompt text
        """
        flow = state_dict['flow']
        tasks = state_dict['tasks']
        conv = state_dict['conversation']
        tones = state_dict.get('tones', {'active': []})
        routes = state_dict.get('routes', {})
        parts = state_dict['participants']
        
        lines = []
        lines.append("")
        lines.append("=" * 70)
        lines.append("  CHATGUIDE DEBUG STATE")
        lines.append("=" * 70)
        
        # Flow
        lines.append("")
        lines.append("FLOW:")
        lines.append(f"  Batches:  {len(flow['batches'])} total")
        lines.append(f"  Current:  {flow['current_index']} -> {flow['batches'][flow['current_index']] if flow['current_index'] < len(flow['batches']) else 'FINISHED'}")
        
        next_batch = flow['batches'][flow['current_index'] + 1] if flow['current_index'] + 1 < len(flow['batches']) else None
        if next_batch:
            lines.append(f"  Next:     {flow['current_index'] + 1} -> {next_batch}")
        
        if flow['persistent']:
            lines.append(f"  Persistent: {', '.join(flow['persistent'])}")
        
        # Tracker
        lines.append("")
        lines.append("TRACKER:")
        
        # Status breakdown
        completed = [k for k, v in tasks['status'].items() if v == 'completed']
        pending = [k for k, v in tasks['status'].items() if v == 'pending']
        failed = [k for k, v in tasks['status'].items() if v == 'failed']
        active = [k for k, v in tasks['status'].items() if v == 'active']
        
        if completed:
            lines.append(f"  Completed: {', '.join(completed)}")
        if pending:
            lines.append(f"  Pending:   {', '.join(pending)}")
        if failed:
            lines.append(f"  Failed:    {', '.join(failed)}")
        if active:
            lines.append(f"  Active:    {', '.join(active)}")
        
        # Results
        if tasks['results']:
            lines.append("")
            lines.append("  Results:")
            for k, v in tasks['results'].items():
                if k not in ['detect_info_updates']:
                    display_v = v if len(v) <= 40 else v[:37] + "..."
                    lines.append(f"    {k} = \"{display_v}\"")
        
        # Attempts (only show > 0)
        attempts = {k: v for k, v in tasks['attempts'].items() if v > 0}
        if attempts:
            lines.append("")
            lines.append(f"  Attempts: {', '.join([f'{k}={v}' for k, v in attempts.items()])}")
        
        # Conversation
        lines.append("")
        lines.append("CONVERSATION:")
        memory_preview = conv['memory'][:60] + "..." if len(conv['memory']) > 60 else conv['memory']
        lines.append(f"  Memory: \"{memory_preview}\"")
        lines.append(f"  History: {len(conv['history'])} messages")
        
        if conv['history']:
            lines.append("  Recent:")
            for msg in conv['history'][-3:]:  # Last 3 messages
                preview = msg if len(msg) <= 60 else msg[:57] + "..."
                lines.append(f"    {preview}")
        
        # Tones & Turn info
        lines.append("")
        lines.append("CONVERSATION:")
        lines.append(f"  Tones: {', '.join(tones['active'])}")
        lines.append(f"  Turn:  {conv['turn_count']}")
        
        # Participants
        lines.append("")
        lines.append("PARTICIPANTS:")
        lines.append(f"  Bot:  {parts['chatbot']}")
        lines.append(f"  User: {parts['user']}")
        
        lines.append("")
        lines.append("=" * 70)
        
        # Optional prompt
        if show_prompt and prompt:
            lines.append("")
            lines.append("FULL PROMPT:")
            lines.append("-" * 70)
            lines.append(prompt)
            lines.append("-" * 70)
        
        return "\n".join(lines)
    
    @staticmethod
    def format_compact(state_dict: Dict[str, Any]) -> str:
        """Compact one-line debug output."""
        flow = state_dict['flow']
        tones = state_dict.get('tones', {'active': []})
        tasks = state_dict['tasks']
        conv = state_dict['conversation']
        
        current = state_dict.get('current_tasks', [])
        completed_count = sum(1 for s in tasks['status'].values() if s == 'completed')
        
        return (f"Turn {conv['turn_count']} | "
                f"Batch {flow['current_index']}/{len(flow['batches'])} | "
                f"Current: {', '.join(current) if current else 'none'} | "
                f"Completed: {completed_count}")



--------------------------------------------------------------------------------

------------------------------------------------------------
FILE: python/chatguide\utils\logger.py
CATEGORY: UTILITIES
STATS: 127 lines, 4,739 bytes
MODIFIED: 2025-12-13 16:52:15
FULL PATH: C:\Users\photo\Desktop\chatguide\python\chatguide\utils\logger.py
------------------------------------------------------------

"""Structured logging for ChatGuide."""

import logging
import json
from typing import Dict, Any, Optional
from datetime import datetime


class ChatGuideLogger:
    """Structured logger for ChatGuide with configurable output."""
    
    def __init__(self, name: str = "chatguide", level: int = logging.INFO, 
                 format_type: str = "json", output_file: Optional[str] = None):
        """Initialize logger.
        
        Args:
            name: Logger name
            level: Logging level (DEBUG, INFO, WARNING, ERROR)
            format_type: "json" or "text"
            output_file: Optional file path for log output
        """
        self.logger = logging.getLogger(name)
        self.logger.setLevel(level)
        self.format_type = format_type
        
        # Remove existing handlers
        self.logger.handlers = []
        
        # Console handler
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        
        if format_type == "json":
            console_handler.setFormatter(JSONFormatter())
        else:
            console_handler.setFormatter(logging.Formatter(
                '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
            ))
        
        self.logger.addHandler(console_handler)
        
        # File handler if specified
        if output_file:
            file_handler = logging.FileHandler(output_file)
            file_handler.setLevel(level)
            if format_type == "json":
                file_handler.setFormatter(JSONFormatter())
            else:
                file_handler.setFormatter(logging.Formatter(
                    '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
                ))
            self.logger.addHandler(file_handler)
    
    def log_event(self, event_type: str, data: Dict[str, Any], level: str = "info"):
        """Log a structured event.
        
        Args:
            event_type: Type of event (e.g., "task_complete", "error")
            data: Event data
            level: Log level (debug, info, warning, error)
        """
        log_data = {
            "event_type": event_type,
            "timestamp": datetime.now().isoformat(),
            **data
        }
        
        log_func = getattr(self.logger, level.lower())
        if self.format_type == "json":
            log_func(json.dumps(log_data))
        else:
            log_func(f"[{event_type}] {json.dumps(data)}")
    
    def task_start(self, task_id: str, description: str):
        """Log task start."""
        self.log_event("task_start", {"task_id": task_id, "description": description})
    
    def task_complete(self, task_id: str, key: str, value: Any):
        """Log task completion."""
        self.log_event("task_complete", {"task_id": task_id, "key": key, "value": str(value)})
    
    def tool_call(self, tool: str, args: Dict[str, Any]):
        """Log tool execution."""
        self.log_event("tool_call", {"tool": tool, "args": args})
    
    def adjustment_fired(self, name: str, actions: list):
        """Log adjustment firing."""
        self.log_event("adjustment_fired", {"name": name, "actions": actions})
    
    def error(self, error_type: str, error: str, context: Dict[str, Any]):
        """Log error."""
        self.log_event("error", {"error_type": error_type, "error": error, **context}, level="error")
    
    def llm_response(self, reply: str, was_silent: bool, task_results: list):
        """Log LLM response."""
        self.log_event("llm_response", {
            "reply_length": len(reply),
            "was_silent": was_silent,
            "task_results": task_results
        })
    
    def checkpoint_saved(self, path: str, session_id: Optional[str]):
        """Log checkpoint save."""
        self.log_event("checkpoint_saved", {"path": path, "session_id": session_id})
    
    def checkpoint_loaded(self, path: str, session_id: Optional[str]):
        """Log checkpoint load."""
        self.log_event("checkpoint_loaded", {"path": path, "session_id": session_id})


class JSONFormatter(logging.Formatter):
    """JSON formatter for structured logs."""
    
    def format(self, record):
        log_data = {
            "timestamp": datetime.fromtimestamp(record.created).isoformat(),
            "level": record.levelname,
            "logger": record.name,
            "message": record.getMessage()
        }
        
        # Add exception info if present
        if record.exc_info:
            log_data["exception"] = self.formatException(record.exc_info)
        
        return json.dumps(log_data)



--------------------------------------------------------------------------------

------------------------------------------------------------
FILE: python/chatguide\utils\response_parser.py
CATEGORY: UTILITIES
STATS: 65 lines, 2,630 bytes
MODIFIED: 2025-12-15 20:20:13
FULL PATH: C:\Users\photo\Desktop\chatguide\python\chatguide\utils\response_parser.py
------------------------------------------------------------

"""Response parser - parses LLM responses."""

import json
from typing import Any, List
from ..schemas import ChatGuideReply, TaskResult


def parse_llm_response(raw: Any) -> ChatGuideReply:
    """Parse LLM response into ChatGuideReply."""
    if raw is None:
        raise ValueError("LLM returned no content")

    if isinstance(raw, ChatGuideReply):
        return raw
    
    if isinstance(raw, dict):
        # Handle task_id field from LLM responses
        # Deduplicate by (task_id, key) pair to allow same key for different tasks
        if "task_results" in raw and isinstance(raw["task_results"], list):
            processed_results = []
            seen = set()
            for tr in raw["task_results"]:
                if isinstance(tr, dict):
                    task_id = tr.get("task_id", "")
                    key = tr.get("key", "")
                    pair = (task_id, key)
                    # Skip duplicates by (task_id, key) pair
                    if key and pair not in seen:
                        seen.add(pair)
                        processed_results.append({
                            "task_id": task_id,
                            "key": key,
                            "value": tr.get("value", "")
                        })
                else:
                    processed_results.append(tr)
            raw["task_results"] = processed_results
        return ChatGuideReply.model_validate(raw)
    
    if isinstance(raw, str):
        parsed = json.loads(raw)
        # Handle task_id field from LLM responses
        # Deduplicate by (task_id, key) pair to allow same key for different tasks
        if "task_results" in parsed and isinstance(parsed["task_results"], list):
            processed_results = []
            seen = set()
            for tr in parsed["task_results"]:
                if isinstance(tr, dict):
                    task_id = tr.get("task_id", "")
                    key = tr.get("key", "")
                    pair = (task_id, key)
                    # Skip duplicates by (task_id, key) pair
                    if key and pair not in seen:
                        seen.add(pair)
                        processed_results.append({
                            "task_id": task_id,
                            "key": key,
                            "value": tr.get("value", "")
                        })
                else:
                    processed_results.append(tr)
            parsed["task_results"] = processed_results
        return ChatGuideReply.model_validate(parsed)
    
    raise ValueError(f"Unexpected response type: {type(raw)}")


--------------------------------------------------------------------------------


================================================================================
CATEGORY: SCRIPTS
================================================================================

------------------------------------------------------------
FILE: python/scripts\validate_config.py
CATEGORY: SCRIPTS
STATS: 82 lines, 2,657 bytes
MODIFIED: 2025-12-15 22:41:27
FULL PATH: C:\Users\photo\Desktop\chatguide\python\scripts\validate_config.py
------------------------------------------------------------

#!/usr/bin/env python3
"""
ChatGuide Config Validator

Validates YAML configuration files and tests ChatGuide initialization.
"""

import sys
import os
from pathlib import Path

# Add the parent directory to path for imports
script_dir = Path(__file__).parent.parent
sys.path.insert(0, str(script_dir))

from chatguide.utils.config_loader import load_config_file, validate_config


def main():
    """Main validation function."""
    if len(sys.argv) < 2:
        print("Usage: python validate_config.py <config_file> [--test-init]")
        print("\nOptions:")
        print("  --test-init    Test ChatGuide initialization (requires GEMINI_API_KEY)")
        sys.exit(1)

    config_path = sys.argv[1]
    test_init = "--test-init" in sys.argv

    print(f"[INFO] Validating config: {config_path}")

    try:
        # Load and validate config
        data = load_config_file(config_path)
        errors = validate_config(data)

        if errors:
            print("[ERROR] Configuration validation failed:")
            for error in errors:
                print(f"  - {error}")
            sys.exit(1)
        else:
            print("[SUCCESS] Configuration is valid!")

        # Print summary
        plan = data.get("plan", [])
        tasks = data.get("tasks", {})
        print(f"\nConfig Summary:")
        print(f"  - {len(plan)} blocks in plan")
        print(f"  - {len(tasks)} tasks defined")
        total_expected = sum(len(tasks.get(tid, {}).get("expects", [])) for block in plan for tid in block if isinstance(tid, str))
        print(f"  - {total_expected} total expected values")

        # Test initialization if requested
        if test_init:
            print("\nTesting ChatGuide initialization...")
            api_key = os.getenv("GEMINI_API_KEY")
            if not api_key:
                print("[ERROR] GEMINI_API_KEY not set, skipping initialization test")
                sys.exit(1)

            try:
                from chatguide import ChatGuide
                cg = ChatGuide(api_key=api_key, config=config_path)
                print("[SUCCESS] ChatGuide initialized successfully!")
                print(f"  - Progress: {cg.get_progress()}")

                # Test first chat turn
                reply = cg.chat()
                print(f"  - First reply: {reply.text[:100]}...")

            except Exception as e:
                print(f"[ERROR] ChatGuide initialization failed: {e}")
                sys.exit(1)

    except Exception as e:
        print(f"[ERROR] {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()


--------------------------------------------------------------------------------

